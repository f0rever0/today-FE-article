[아티클](https://ykss.netlify.app/translation/10_web_development_trends_in_2023/?utm_source=substack&utm_medium=email)

# 2023년 웹 개발 트렌드 10가지

## ✨ (메타) 프레임워크

메타 프레임워크(Next.js) 등장으로 애플리케이션이 클라이언트 사이드 렌더링(CSR)에서 서버 사이드 렌더링(SSR)으로 전환되고 있다.

- CSR : 서버는 요청을 받으면 클라이언트에 HTML과 JS를 보내준다. 클라이언트는 그것을 받아 렌더링을 시작한다.
- SSR : 요청을 받으면 서버 쪽에서 HTML과 JS 렌더링을 마쳐 클라이언트에게 보낸다.

## ✨ 애플리케이션 및 렌더링 패턴

지난 10년(2010~2020년)은 Knockout.js, Ember.js를 시작으로 Angular.js, React.js, Vue.js에 이르기까지 클라이언트 사이드 렌더링(ㅌCSR)을 사용하는 단일 페이지 애플리케이션(SPA)이 주를 이루었다면, 최근 몇 년 동안 자바스크립트 메타 프레임워크를 사용하는 서버 사이드 렌더링(SSR)에 대한 관심이 높아졌다.

몇 년 동안 Next.js가 이러한 트렌드를 주도해 왔지만, SvelteKit과 같은 다른 메타 프레임워크가 그 뒤를 따라잡고 있다.

몇 년 전 성능 최적화에 대한 트렌드가 SSR과 SSG로 시작되었지만, 증분 정적 재생성(ISR)과 Streaming SSR과 같은 보다 세밀한 렌더링 기법이 등장했다.

- SSG : 프로젝트 빌드 시에 페이지를 사전 렌더링해두어, 요청을 받으면 이미 완성된 파일을 반환한다.
- ISR : 전체 웹사이트를 리빌드 하는 대신 페이지 단위(예: 60초마다 페이지 X를 리빌드)로 웹사이트를 정적으로 리빌드한다.
- Streaming SSR : 서버 측 렌더링의 단일 스레드 병목 현상을 최적화한다. 일반적인 SSR은 렌더링 된 콘텐츠를 클라이언트에 한 번에 전송하기 위해 데이터가 서버에서 대기해야 하지만, Streaming SSR을 사용하면 개발자가 애플리케이션을 청크로 분할하여 서버에서 클라이언트로 점진적으로 병렬 전송할 수 있다.

## ✨ 엣지에서 서버리스

서버리스 사용자에게 더 빠른 웹사이트와 웹 애플리케이션을 제공한다. 실행 중인 (원격) 서버가 존재하지만 개발자는 서버 및 관련 작업(예: On-demand 인프라 확장)을 관리할 필요가 없다. 대신 클라우드 공급자가 처리하는 단일 기능을 서버리스 기능으로 배포하기만 하면 된다.

완벽한 환경이라면 서버리스 함수는 사용자와 가장 가까운 곳에서 실행될 것이며, 이는 클라이언트-서버 왕복 시간이 가장 짧아져 사용자 경험이 개선된다는 것을 의미한다. 가능한 한 사용자와 가까운 곳에 배포하는 것을 엣지 컴퓨팅과 엣지 기능이라는 용어로 표현한다.

엣지 기능은 최종 사용자와의 연결이 짧기 때문에 SSG/SSR 콘텐츠를 더 빠르게 제공할 뿐만 아니라 결과를 사용자에게 더 가깝게 캐시 할 수도 있습니다. 엣지 기능은 최종 사용자와의 연결이 짧기 때문에 SSG/SSR 콘텐츠를 더 빠르게 제공할 뿐만 아니라 결과를 사용자에게 더 가깝게 캐시 할 수 있다.

엣지 컴퓨팅을 통해 비용 절감되는 이점도 얻을 수 있다.

## ✨ 데이터베이스 르네상스

서버리스 함수를 사용하면 하나의 연결을 유지하는 서버가 하나도 없고 데이터베이스에 1:1로 연결되는 서버리스 함수가 많아져 너무 많은 데이터베이스 연결을 개방하는 문제에 직면하게 된다. 전 세계적인 서버리스 서비스의 경우, 엣지 캐싱 또는 분산형 읽기 전용 데이터베이스를 제공하여 데이터를 사용자에게 더 가깝게 이동시켜 지연 시간을 최소화한다.

## ✨ 자바스크립트 런타임

Node.js는 브라우저 자체가 아닌 크롬에서 구현한 V8이라는 자바스크립트 엔진을 사용한다.
Ryan Dahl은 개발자에게 브라우저 API, 타입스크립트 및 표준 라이브러리와 유사한 환경을 즉시 사용할 수 있는 더 안전하고 빠른 환경을 제공하기 위해 Node의 후속 버전으로 Deno를 발표했다. 하지만 V8에서도 실행되는 Deno는 오늘날 수많은 자바스크립트 런타임 중 하나에 불과하다.

## ✨ 모노레포

모노레포란 두 개 이상의 프로젝트가 동일한 저장소에 저장되는 소프트웨어 개발 전략을 뜻한다.
[모노레포](https://d2.naver.com/helloworld/0923884)
모노레포는 대규모 애플리케이션에만 국한된 것이 아니라 소규모 애플리케이션과 오픈 소스 프로젝트에도 유용하게 활용될 수 있다.

예를 들어, 공유 패키지를 모두 사용하는 실제 애플리케이션(예: 클라이언트 측 렌더링이 있는 app.mywebsite.com)은 공유 디자인 시스템 패키지만 사용하고, SEO를 염두에 둔 홈/제품/랜딩 페이지(예: 서버 측 렌더링 또는 정적 사이트 생성이 있는 mywebsite.com)는 공유 UI 컴포넌트 및 공유 디자인 시스템, 패키지를 사용하는 기술 문서 페이지(예: docs.mywebsite.com)는 공유 디자인 시스템 패키지를 사용한다.

Turborepo를 사용하면 팀은 모노레포 내에서 모든 애플리케이션과 패키지에 대한 빌드 파이프라인을 생성할 수 있다.

## ✨ 유틸리티 우선 CSS

Tailwind CSS는 유틸리티 우선 CSS의 대표적인 예이다.
지난 몇 년 동안 Styled Components(SC) 및 Emotion과 같은 CSS-in-JS는 웹 애플리케이션의 스타일을 지정하는 데 널리 사용되어 왔지만, SSR의 주된 목표 중 하나가 성능이라면 이는 적절하지 않다.

CSS-in-JS는 번들 크기 증가(SC는 12.7kB, Emotion은 7.9kB)시키고 DOM에 삽입하기 전에 CSS 직렬화로 인한 런타임 오버헤드를 발생시킨다.

따라서 사전 정의된 UI 컴포넌트(예: DaisyUI)와 결합된 유틸리티 우선 CSS(예: Tailwind CSS, UnoCSS), CSS Module 또는 제로 런타임/컴파일 타임 CSS-in-JS(예: vanilla-extract, linaria, astroturf, compiled)을 사용하여 성능을 개선시킬 수 있다.

## ✨ 타입스크립트를 통한 엔드 투 엔드 타입 안전성

클라이언트-서버 통신을 위해서는 REST와 GraphQL을 사용한다.
[GraphQL과 REST의 차이점](https://hwasurr.io/api/rest-graphql-differences/)

그러나 REST/GraphQL을 대체하여 사용할 수 있는 타입 안전성 API로 새롭게 떠오르고 있는 tRPC가 있다. 프론트엔드와 백엔드가 코드를 공유하는 타입스크립트 모노레포에서 작업하는 경우, tRPC를 사용하면 타입 스키마를 중간 생성하지 않고도 백엔드에서 프론트엔드 애플리케이션으로 모든 타입을 내보낼 수 있다. 이후 프론트엔드에서는 실제 클라이언트-서버 통신을 활성화하기 위해 내부적으로 HTTP로 연결된 타입화된 함수를 사용하여 백엔드의 API를 호출할 수 있다.

## ✨ 빌드 도구

몇 년 동안 React 생태계에서는 이상 React 설정이 포함된 사용자 정의 Webpack을 구성할 필요 없이 바로 사용할 수 있는 React 스타터인 create-react-app(CRA)이 지배적이었다.

Vite는 스타터 프로젝트를 만드는 데 널리 사용되는 모든 프레임워크(예: React.js)와 함께 작동하기 때문에 단일 페이지 애플리케이션(SPA)에 관한 새로운 빌드 도구이다. 다른 자바스크립트 번들러에 비해 Go로 작성되어 경쟁 제품(예: Webpack)보다 종속성을 10~100배 빠르게 번들링하는 esbuild에서 그 강력한 성능을 얻을 수 있다.

Vite의 생태계는 Vitest(Jest의 대체 테스트 도구)와 같은 추가 기능으로 번창하고 있지만, Vercel의 Turbopack과 같은 다른 경쟁자가 최근에 등장했다.

## ✨ AI 주도 개발

- GitHub Copilot
- ChatGPT
